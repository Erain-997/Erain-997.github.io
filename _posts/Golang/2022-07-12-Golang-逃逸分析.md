---
layout:     post
title:      Golang-逃逸分析
subtitle:   逃逸分析、堆栈
date:       2022-07-12
author:     Erain
header-img: img/home-bg.jpg
categories: Golang
catalog: true
tags:
    - Golang
---

# 前言

堆（Heap）与栈（Stack），不同场景下，堆与栈代表不同的含义。一般情况下，有两层含义：

1. 程序内存布局场景下，堆与栈表示两种内存管理方式；
1. 数据结构场景下，堆与栈表示两种常用的数据结构。

所谓逃逸分析（Escape analysis）是指由编译器决定内存分配的位置，不需要程序员指定。 函数中申请一个新的对象：

- 如果分配在栈中，则函数执行结束可自动将内存回收；
- 如果分配在堆中，则函数执行结束可交给GC（垃圾回收）处理；

补充：

- 栈由操作系统自动分配释放 ，用于存放函数的参数值、局部变量等，其操作方式类似于数据结构中的栈。 其中函数中定义的局部变量按照先后定义的顺序依次压入栈中，也就是说相邻变量的地址之间不会存在其它变量。
  栈的内存地址生长方向与堆相反，由高到底，所以后定义的变量地址低于先定义的变量。栈中存储的数据的生命周期随着函数的执行完成而结束。
- 堆的内存地址生长方向与栈相反，由低到高，但需要注意的是，后申请的内存空间并不一定在先申请的内存空间的后面，原因是先申请的内存空间一旦被释放，后申请的内存空间则会利用先前被释放的内存，从而导致先后分配的内存空间在地址上不存在先后关系。
  堆中存储的数据若未释放，则其生命周期等同于程序的生命周期。

# 逃逸策略

每当函数中申请新的对象，编译器会根据该对象是否被函数外部引用来决定是否逃逸：

- 如果函数外部没有引用，则优先放到栈中，并不是一定，如对象过大，会被分配到堆上；
- 如果函数外部存在引用，则必定放到堆中，因为被调用的函数不知道这个值；
- 在循环外声明的变量在循环内的赋值后会失效，所以会逃逸；
- 在闭包外声明的变量在闭包内的赋值后失效；
- 动态类型逃逸，interface{}类型。

注意，对于函数外部没有引用的对象，也有可能放到堆中，比如内存过大超过栈的存储能力。

# 逃逸分析的目的

逃逸分析是一种确定指针动态范围的方法，简单来说就是分析在程序的哪些地方可以访问到该指针。

1. 逃逸分析在编译阶段完成
1. 逃逸分析目的是决定内分配地址是栈还是堆
1. 栈上分配内存比在堆中分配内存有更高的效率，合理分配资源
1. 栈上分配的内存不需要GC处理，堆上分配的内存使用完毕会交给GC处理
1. 申请、分配、回收内存的系统开销增大(相对于栈)
1. 动态分配产生一定量的内存碎片

# 运行

代码运行：

```bash
$ go build -gcflags '-m -l' main.go
```

- -m 会打印出逃逸分析的优化策略。完整版：*go build -gcflags="-m -m -m -m -m -W -W"*
- -l 会禁用函数内联，在这里禁用掉 inline 能更好的观察逃逸情况，减少干扰。

# 思考

1. 函数传递指针真的比传值效率高吗？      
   我们知道传递指针可以减少底层值的拷贝，可以提高效率，但是如果拷贝的数据量小，由于指针传递会产生逃逸，可能会使用堆，也可能会增加GC的负担，所以传递指针不一定是高效的。

1. 每个 Go 版本的逃逸分析都会有所不同(会改变，会优化)，了解即可