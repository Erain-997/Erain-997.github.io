---
layout:     post
title:      TCP与UDP
subtitle:   UDP、TCP，面试必备
date:       2022-09-08
author:     Erain
header-img: img/home-bg.jpg
categories: 压测
catalog: true
tags:
  - TCP
---



# TCP和UDP的区别有哪些？

1. **连接**     
   TCP是面向连接的传输层协议，传输数据前要先建立连接； UDP是不需要连接，即刻传输数据；

1. **服务对象**     
   TCP是一对一的两点服务，即一条连接只有两个端点； UDP支持一对一、一对多、多对多的交互通信；

1. **可靠性**      
   TCP是可靠交付数据，数据可以无差错、不丢失、不重复、按需到达； UDP是尽最大努力交付，不保证可靠交付数据；

1. **拥塞控制、流量控制**       
   TCP有拥塞控制和流量控制机制，保证数据传输的安全性； UDP则没有，即使网络非常拥堵了，也不会影响UDP的发送效率；

1. **首部开销**     
   TCP首部长度较长，会有一定的开销，首部在没有使用“选项”字段时是20个字节，如果使用“选项”字段则会变得更长（最大60字节）； UDP首部只有8个字节，并且是固定不变的，开销较小；

1. **传输方式**     
   TCP是流式传输，没有边界，但保证顺序和可靠性； UDP是一个包一个包的发送，是有边界的，且可能丢包和乱序；

1. **分片不同**      
   TCP数据包的大小如果大于MSS，则会在传输层进行分片，目标主机收到后同样会在传输层组装TCP数据包，如果中途丢失分片，只需重传丢失的这个分片； UDP的数据大小如果大于MTU，则会在 IP层（网络层）
   进行分片，目标主机收到后会在IP层组包并传递给传输层，如果丢失一个分片，则需要重传整个报文，重传效率较低。

# TCP和UDP的应用场景分别有哪些？

1. TCP

> FTP文件传输；  
> HTTP / HTTPS；

1. UDP

> （数据总量较小的业务适合使用UDP进行传输，可避免首部开销，而重传等功能则由应用程序完成）     
> DNS、SNMP；     
> 广播通信；

# 为什么UDP有“包长度”字段，而TCP没有？

首先明确“包长度”这个字段无论对于TCP还是UDP来说都不是必需的，因为可以从IP包长度推算出来： TCP数据净荷 = IP总长度 - IP头长 - TCP头长； （TCP头长在TCP头的len域中）

UDP数据长度同样可以使用这样的公式，加入“包长度”这个字段可能是为了UDP头按4字节对齐吧。

# TCP

面向连接的、可靠的、字节流式的 传输层的 协议。

1. 面向连接的    
   在传输数据之前必须建立一对一的连接，

2. 可靠地      
   保证每个数据的可靠到达，TCP 主要通过以下几个手段实现可靠性： 序列号 + 确认号 + 重传 + 首部和数据的CRC校验和 + 重排序 + 重复丢弃 + 流量控制 + 拥塞控制

3. 字节流式的    
   指的是从应用层看到的TCP发上来的数据是“流式的、连续的”，TCP不会向数据中插入记录标志或消息边界。 例如发送端分三次发出10 Byte、20 Byte、50
   Byte，TCP不会在这三段报文之间插入边界记录，接收端也感知不到发送端是按几次发送的。

## TCP连接

TCP连接由四元组唯一确定： 源IP、目的IP、源端口号、目的端口号。

一个TCP连接需要收发两端维护以下信息：

1. Socket套接字（四元组信息）；
2. 序列号（收发报文、排序、重复丢弃、重传）；
3. 窗口大小（做流量控制、拥塞控制）。

## TCP头部数据包

![](/img/post/TCP/TCP头部.png)
字段说明：

1. len      
   头部长度字段4 bit，2^4 = 0 - 15，TCP头最长 15 * 4 Byte = 60 Byte，取值范围 20 Byte <= LEN <= 60 Byte。 以 32 bit 为单位，表示TCP头有多少个 32
   bit（4字节），即图中的一行。

2. winsize     
   窗口大小16 bit，最大值65535，TCP窗口常规大小65535，有WSCALE（window scale）选项可以扩充TCP头长，给高速和大延迟网络提供了更大的窗口和改进性能。

3. CRC      
   校验和覆盖头部和数据，由发送方计算和保存，由接收方验证。

4. 紧急指针     
   只有在URG被置位时才有效，指明紧急数据在TCP数据中的位置（偏移量）。

5. 标志位
    1. URG：表明紧急指针字段有效；
    2. ACK：表明ACK字段有效；
    3. PSH：接收方应立即推送数据给应用程序；
    4. RST：重置连接，复位；
    5. SYN：初始化一个连接的同步报文段；
    6. FIN：该报文段的发送方已经结束向对端发送数据；（FIN的发送方表明自己已经无数据可发）

6. seq 序列号     
   注意TCP的序列号指的是发送的字节数，而不是发送的报文个数。 例如，一个报文的 seq = 1000，len = 1400，那么下一个报文段的 seq 就是2400（而不是1001）。 同样，ack回复的也是字节数。

7. SYN、ACK     
   SYN报文段是被可靠传输的（消耗ISN、会被重传）， ACK则不是（不消耗ISN，不被重传）。

## 什么是流量控制？

“流量控制”是用于保护接收方一端的一种机制，在保证数据发送速率尽可能高、充分利用网络带宽资源的前提下， 避免发送端的发送速率过大而超过接收方的处理速率，导致数据在接收方被丢弃。

流量控制的实现可以有两种方式：

* 基于 速率 的流量控制；（rate-based）
* 基于 窗口 的流量控制；（window-based）

1. 基于 “速率” 的流量控制：（rate-based）    
   给发送方指定某个速率，确保速率永远不能超过这个速率来发送， 这种类型的流量控制最适合流应用程序，可被用作广播和组播发现。 这种流量控制方式的缺点是不能实时的根据中间网络情况进行动态的发送速率调整。

1. 基于 “窗口” 的流量控制：（window-based）     
   窗口大小不是固定的，由发送方通知接收方使用多大的窗口，称为窗口通告或窗口更新。（其实就是接收端通过ACK报文中的winsize字段通知发送端更新发送窗口大小。） 发送窗的大小取决于确认窗口和拥塞窗口中的最小值：

> W = min(awnd, cwnd);

W表示发送窗大小；      
awnd = Acknowledgement Window，接收端返回的确认窗口大小；     
cwnd = Congestion Window，拥塞窗口大小，由拥塞控制算法（慢启动、拥塞避免、拥塞发生、快速恢复等来决定拥塞窗口的大小）。

窗口更新的实现： 接收方会与ACK一起反馈给发送方，发送方在将窗口右移（左边界右移）的同时更新窗口大小。

## 什么是拥塞控制？

流量控制解决的只是发送端与接收端之间“点对点”的防止丢包问题：     
如果接收方的内存不够了，超出了接收方的处理能力的时候，就通知发送方将发送速度慢下来。

但是，网络中还有许多的路由器，它们同样有内存限制，且通信速率受网络质量限制，如果发送方的发送速率超出了路由器的处理能力而导致丢包，这就需要拥塞控制解决。

流量控制 解决的是接收方主机内存受限的情况；— 保护接收方    
拥塞控制 解决的是传输网络中路由器内存受限或网络质量导致的底层丢包的问题。 — 保护中间网络（IP网络）不被压垮，当出现拥塞时，减小发送数据，等待网络整体恢复

二者都是为了防止丢包，而对发送方的发送速率做出限制的策略。

# UDP

## UDP头部

UDP的头部只有 8 个字节（64 bit），提供面向无连接的通信服务。 包长度字段：UDP头部+数据的长度之和。